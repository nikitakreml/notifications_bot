services:
  bot:
    build:
      context: .
    image: notifications_bot:latest
    container_name: notifications_bot-bot-1
    restart: always

    # Переменные окружения берём из .env
    env_file:
      - .env

    # Безопасность: корневая ФС только для чтения
    read_only: true
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL

    # Запускать контейнер от вашего пользователя (UID/GID заданы в .env)
    user: "${UID}:${GID}"

    # --- ИЗМЕНЕНИЕ 1: ИСПОЛЬЗУЕМ ИМЕНОВАННЫЙ ТОМ ---
    # Это изолирует БД и решает проблему блокировки.
    volumes:
      - botdata:/data
      - type: tmpfs
        target: /tmp
      - type: tmpfs
        target: /var/tmp

    # Мягкое завершение, чтобы не ловить exit 137
    stop_signal: SIGINT
    stop_grace_period: 60s

    # Ограничения и лог-ротация (под VPS с малой RAM)
    mem_limit: 256m
    memswap_limit: 1g
    logging:
      driver: json-file
      options:
        max-size: "10m"
        max-file: "3"

    # Healthcheck: проверяем доступность Telegram API
    healthcheck:
      test: >
        python -c "import asyncio, os; from aiogram import Bot;
        async def check():
          bot = Bot(token=os.environ['BOT_TOKEN']);
          try:
            await bot.delete_webhook();
            me = await bot.get_me();
            exit(0 if me else 1);
          except Exception:
            exit(1);
          finally:
            await bot.session.close();
        asyncio.run(check())"
      interval: 1m
      timeout: 20s
      retries: 3
      start_period: 30s

# --- ИЗМЕНЕНИЕ 1 (продолжение): ОБЪЯВЛЯЕМ ИМЕНОВАННЫЙ ТОМ ---
# Docker сам будет управлять этой папкой.
volumes:
  botdata:
    driver: local